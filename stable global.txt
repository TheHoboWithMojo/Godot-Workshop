extends Node2D

# --- Member Variables ---
@onready var player = $"/root/Game/Player"
@onready var frames: int = 0

var item_keys = "res://data/item_positions.json"

func binary_search_items(search_term: String, keys_file_path) -> int:
	var file = FileAccess.open(keys_file_path, FileAccess.READ)
	var items = JSON.parse_string(file.get_as_text())
	file.close()
	
	var left = 0
	var right = items.size() - 1
	
	while left <= right:
		var mid = (left + right) / 2
		var item_name = items[mid][0]
		
		# Compare the strings
		if item_name == search_term:
			return items[mid][1] # Return the byte position
		elif item_name < search_term:
			left = mid + 1
		else:
			right = mid - 1
	
	print("Error: Binary Search ", search_term, " not found in ", keys_file_path)
	return -1 # Item not found

# Private variables for stats
var _stats: Dictionary = {
	"crit_chance": 0.01,
	"health": 100.0,
	"health_regen": 0.05,
	"speed_mult": 1.00,
	"speed": 50,
}

# Stat Constraints
var _max_stat_values: Dictionary = {
	"crit_chance": 1.0,  # 100% max crit chance
	"speed_mult": 5.0    # 500% max movement speed
}

var _min_stat_values: Dictionary = {
	"speed_mult": 1.0    # Minimum speed multiplier 100% (regular speed can enforce 0)
}

# Player Traits Dictionary
var _player_traits: Dictionary = {
	"war hero": {"has": false, "description": "You've been through hell and back, unlocks gruff dialogue options.", "buff1": "health * 1.05"},
	"scholar": {"has": false, "description": "The library is your true home, unlocks informed dialogue options."}
}

# Player Perks Dictionary
var _player_perks: Dictionary = {
	"heavy handed": {"has": false, "description": "You punch twice as hard! +3 to Strength.", "buff1": "crit_chance + 0.05", "buff2": "health_regen / 2"}
}

# Timelines Dictionary
var Timelines: Dictionary = {
	"npc": {"completed": false, "repeatable": false}
}

# --- BuffString Class ---
class BuffString: # This class creates the data type for buffs [stat, operator, value]
	var stat: String
	var operator: String
	var value: float

	func _init(buff_str: String):
		var words = buff_str.strip_edges().split(" ", false)

		if words.size() != 3:
			print("Error: BuffString(): Invalid format. Expected 'stat operator value' but got:", buff_str)
			return
		
		self.stat = words[0]
		self.operator = words[1]
		
		if not words[2].is_valid_float():
			print("Error: BuffString(): Invalid value. Expected a number but got:", words[2])
			return
		
		self.value = words[2].to_float()

		if self.operator not in ["*", "-", "+", "/"]:
			print("Error: BuffString(): Invalid operator. Expected one of ['*', '-', '+', '/'] but got:", self.operator)
			return

		if self.stat == "":
			print("Error: BuffString(): Stat cannot be empty.")
			return


# --- Getter for Player Stats ---
func player_get_stat(stat: String) -> float:
	return _stats.get(stat, 0.0)

# --- Setter for Player Stats with Constraints ---
func player_change_stat(buff_str: String):
	var buff = BuffString.new(buff_str)
	
	# If BuffString failed initialization due to errors, stop execution
	if buff.stat == "" or buff.operator == "" or buff.value == 0.0:
		return
	
	# Ensure the stat exists before modifying
	if not _stats.has(buff.stat):
		print("Error: player_change_stat(): Stat '", buff.stat, "' does not exist.")
		return
	
	# Apply the operator
	match buff.operator:
		"*": _stats[buff.stat] *= buff.value
		"-": _stats[buff.stat] -= buff.value
		"+": _stats[buff.stat] += buff.value
		"/": 
			if buff.value != 0:
				_stats[buff.stat] /= buff.value
	
	# Apply stat set constraints (clamp min/max)
	_stats[buff.stat] = clamp(
		_stats[buff.stat], 
		_min_stat_values.get(buff.stat, 0.0),   # Default min to 0 if not found in _min_stat_values
		_max_stat_values.get(buff.stat, 2147483647.0)  # Default max to int limit if not found in _max_stat_values
	)

# --- Player Traits & Perks Methods ---
func print_player_perks():
	print("Available Perks:\n")
	for perk in _player_perks.keys():
		print(perk, ": ", _player_perks[perk]["description"], "\n")

func print_player_traits():
	print("Available Traits:\n")
	for _trait in _player_traits.keys():
		print(_trait, ": ", _player_traits[_trait]["description"], "\n")

func player_add_trait(trait_name: String):
	if trait_name in _player_traits and not _player_traits[trait_name]["has"]:
		_player_traits[trait_name]["has"] = true
		print(trait_name, " trait added!")
		_parse_buffs(_player_traits, trait_name) 
	else:
		print("Trait does not exist or already added!")

func player_add_perk(perk_name: String):
	if perk_name in _player_perks and not _player_perks[perk_name]["has"]:
		_player_perks[perk_name]["has"] = true
		print(perk_name, " perk added!")
		_parse_buffs(_player_perks, perk_name) 
	else:
		print("Perk does not exist or already added!")

# --- Buff Parsing Method ---
func _parse_buffs(buff_dict: Dictionary, buff_name: String = ""):
	# If a specific buff name is given, only apply that buff
	if buff_name and buff_name in buff_dict:
		var buff_data = buff_dict[buff_name]
		if not buff_data.get("has", false):
			return
		for buff_key in buff_data:
			if buff_key.begins_with("buff"):
				player_change_stat(buff_data[buff_key])
		return
	
	# If no buff name is given, apply all buffs
	for _buff_name in buff_dict.keys():
		if buff_dict[_buff_name].get("has", false):
			for buff_key in buff_dict[_buff_name]:
				if buff_key.begins_with("buff"):
					player_change_stat(buff_dict[_buff_name][buff_key])

# --- Timeline Methods ---
func _is_timeline_completed(timeline: String) -> bool:
	return Timelines[timeline]["completed"] == true

func _is_timeline_repeatable(timeline: String) -> bool:
	return Timelines[timeline]["repeatable"] == true
	
func _is_timeline_running() -> bool:
	return Dialogic.current_timeline != null

func start_dialog(timeline: String) -> void:
	if _is_timeline_running():
		print("Error: A timeline is already running! Cannot start a new one.")
		return

	if timeline in Timelines:
		if _is_timeline_completed(timeline) and not _is_timeline_repeatable(timeline):
			print("Timeline ", timeline, " is already completed and not repeatable.")
			return
		
		Timelines[timeline]["completed"] = true
		Dialogic.start(timeline)
	else:
		print("Error: The timeline '", timeline, "' does not exist.")
		
# --- Vector and Debug Methods ---

# Provides the vector between any node and the player
func get_vector_to_player(self_node: Node2D) -> Vector2:
	if player:
		return player.global_position - self_node.global_position
	else:
		print(self, "get_vector_to_player()", "Player Path Has Changed")
		return Vector2.ZERO

# Debug method for visualizing the vector, angle, and length
func debug() -> void:
	print("1. get_vector_to_player()")
	print("""
Show Vectors:

func _draw() -> void:
	draw_line(Vector2.ZERO, vector_to_player, Color.GREEN, 2.0)

func _ready() -> void:
	queue_redraw()

func _process(_delta: float) -> void:
	vector_to_player = get_vector_to_player(self)
	queue_redraw()
""")

# --- Frame Updates ---
func _ready() -> void:
	frames += 1
	if frames >= 100:
		frames = 0
